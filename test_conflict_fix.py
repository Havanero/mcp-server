#!/usr/bin/env python3\n\"\"\"\nTest that the tool name conflict warning is resolved\n\"\"\"\nimport asyncio\nimport sys\nimport logging\nimport io\n\n# Capture logging output to check for warnings\nsys.path.append('.')\nfrom plugin_manager import PluginManager\n\n\nasync def test_no_conflicts():\n    \"\"\"Test that decorator tools don't conflict with themselves\"\"\"\n    print(\"\ud83e\udde8 Testing Tool Name Conflict Resolution\")\n    print(\"-\" * 45)\n    \n    # Create a string buffer to capture log output\n    log_capture = io.StringIO()\n    \n    # Create a logger that writes to our buffer\n    logger = logging.getLogger()\n    logger.setLevel(logging.DEBUG)\n    \n    # Clear existing handlers\n    for handler in logger.handlers[:]:\n        logger.removeHandler(handler)\n    \n    # Add our capture handler\n    handler = logging.StreamHandler(log_capture)\n    handler.setFormatter(logging.Formatter('%(levelname)s:%(message)s'))\n    logger.addHandler(handler)\n    \n    try:\n        # Load plugins\n        manager = PluginManager(\"tools\")\n        tools = await manager.discover_and_load_tools()\n        \n        # Get the captured log output\n        log_output = log_capture.getvalue()\n        \n        # Check for conflict warnings\n        conflict_warnings = [line for line in log_output.split('\\n') \n                           if 'Tool name conflict' in line]\n        \n        print(f\"\ud83d\udcca Results:\")\n        print(f\"  \u2705 Loaded {len(tools)} tools successfully\")\n        print(f\"  \ud83d\udcc8 Tools: {list(tools.keys())}\")\n        \n        if conflict_warnings:\n            print(f\"  \u26a0\ufe0f  Found {len(conflict_warnings)} conflict warnings:\")\n            for warning in conflict_warnings:\n                print(f\"    {warning}\")\n            print(f\"  \u274c Fix did not resolve all conflicts\")\n        else:\n            print(f\"  \u2705 No tool name conflict warnings!\")\n            print(f\"  \u2705 Fix successfully resolved the issue\")\n        \n        # Show decorator vs traditional tool breakdown\n        decorator_tools = [name for name, tool in tools.items() \n                         if hasattr(tool, '_func')]\n        traditional_tools = [name for name, tool in tools.items() \n                           if not hasattr(tool, '_func')]\n        \n        print(f\"\\n\ud83d\udcca Tool Breakdown:\")\n        print(f\"  \ud83c\udfa8 Decorator tools ({len(decorator_tools)}): {decorator_tools}\")\n        print(f\"  \ud83d\udd27 Traditional tools ({len(traditional_tools)}): {traditional_tools}\")\n        \n        # Test that string_utils works\n        if \"string_utils\" in tools:\n            print(f\"\\n\ud83e\udde8 Testing string_utils tool:\")\n            result = await manager.execute_tool(\"string_utils\", {\n                \"operation\": \"upper\",\n                \"text\": \"conflict resolved!\"\n            })\n            content = result.get('content', [])\n            if content:\n                print(f\"  \u2705 Result: {content[0].get('text', '')}\")\n            \n        return len(conflict_warnings) == 0\n        \n    except Exception as e:\n        print(f\"  \u274c Error during test: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False\n    \n    finally:\n        # Restore normal logging\n        logger.removeHandler(handler)\n        logging.basicConfig(level=logging.INFO, \n                          format='%(asctime)s - %(levelname)s - %(message)s')\n\n\nif __name__ == \"__main__\":\n    success = asyncio.run(test_no_conflicts())\n    \n    if success:\n        print(f\"\\n\ud83c\udf89 Success! Tool name conflicts resolved.\")\n        print(f\"\ud83d\ude80 The server should now start without warnings.\")\n    else:\n        print(f\"\\n\u274c Test failed. Check the output above for issues.\")\n        sys.exit(1)\n